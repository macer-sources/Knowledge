
# 运算符及运算  



## 1. 运算符:

|优先级(越小越高)|运算符|说明|结合性|
|---|---|---|---|
|1|__()__|聚组:a*(b+c)|N/A|
|2|__[] () . ++ --__ |数组下标__[]__,方法参数__fun(arg1,arg2,arg3)__,属性访问__a.b__,自增/减后缀__a++  a--__|L - R|
|3|__++ -- + - !__|自增/减前缀__++a  --a__,正负号(一般正号不写)__a ,-a__,取反__!false__|R - L|
|4|__* /__|乘除数学运算|L - R|
|5|__+ -__|加减数学运算|L - R|
|7|__< > <= >=__|关系运算符|L - R|
|8|__== !=__|相等性运算符|L - R|
|12|__&&__|逻辑与|L - R|
|13|__^^__|逻辑排他或(用处基本等于!=)|L - R|
|14|__\|\|__|逻辑或|L - R|
|15|__? :__|三目运算符|L - R|
|16|__= += -= *= /=__|赋值与复合赋值|L - R|
|17|__,__|顺序分配运算|L - R|

*ps 左值与右值:*

    左值:表示一个储存位置,可以是变量,也可以是表达式,但表达式最后的结果必须是一个储存位置.

    右值:表示一个值, 可以是一个变量或者表达式再或者纯粹的值.

    操作符的优先级：决定含有多个操作符的表达式的求值顺序，每个操作的优先级不同.

    操作符的结合性：决定相同优先级的操作符是从左到右计算，还是从右到左计算。





## 2. 基础类型间的运算:

>  不支持隐式类型转换  

glsl中,没有隐式类型转换,原则上glsl要求任何表达式左右两侧(l-value),(r-value)的类型必须一致 也就是说以下表达式都是错误的:

```cpp
int a =2.0; //错误,r-value为float 而 lvalue 为int.
int a =1.0+2;
float a =2;
float a =2.0+1;
bool a = 0; 
vec3 a = vec3(1.0, 2.0, 3.0) * 2;
```



## 3. 不同类型之间运算  

* __`float` 与 `int`__

    float与float , int与int之间是可以直接运算的,但float与int不行.它们需要进行一次显示转换.即要么把float转成int: __int(1.0)__ 
    ,要么把int转成float: __float(1)__ ,以下表达式都是正确的:

    ```javascript
    int a=int(2.0);
    float a= float(2);
    int a=int(2.0)*2 + 1;
    float a= float(2)*6.0+2.3;
    ```


* __`float`  与 `vec(向量)` `mat(矩阵)`__   

    vec,mat这些类型其实是由float复合而成的,当它们与float运算时,其实就是在每一个分量上分别与float进行运算,这就是所谓的`逐分量`运算.glsl里
    大部分涉及vec,mat的运算都是`逐分量`运算,但也并不全是. 下文中就会讲到特例.

    `逐分量`运算是线性的,这就是说 vec 与 float 的运算结果是还是 vec.

    int 与 vec,mat之间是不可运算的, 因为vec和mat中的每一个分量都是 float 类型的. 无法与int进行逐分量计算.

    下面枚举了几种 float 与 vec,mat 运算的情况

    ```cpp
    vec3 a = vec3(1.0, 2.0, 3.0);
    mat3 m = mat3(1.0);
    float s = 10.0;
    vec3 b = s * a; // vec3(10.0, 20.0, 30.0)
    vec3 c = a * s; // vec3(10.0, 20.0, 30.0)
    mat3 m2 = s * m; // = mat3(10.0)
    mat3 m3 = m * s; // = mat3(10.0)
    ```


* __`vec(向量)` 与 `vec(向量)`__  

    两向量间的运算首先要保证操作数的阶数都相同.否则不能计算.例如: vec3*vec2 vec4+vec3 等等都是不行的.

    它们的计算方式是两操作数在同位置上的分量分别进行运算,其本质还是逐分量进行的,这和上面所说的float类型的
    逐分量运算可能有一点点差异,相同的是 vec 与 vec 运算结果还是 vec, 且阶数不变.

    ```cpp
    vec3 a = vec3(1.0, 2.0, 3.0);
    vec3 b = vec3(0.1, 0.2, 0.3);
    vec3 c = a + b; // = vec3(1.1, 2.2, 3.3)
    vec3 d = a * b; // = vec3(0.1, 0.4, 0.9)
    ``` 

    ![](http://wshxbqq-wshxbqq.stor.sinaapp.com/2016-08-08_16-15-35_329___2.png)



* __`vec(向量)` 与 `mat(矩阵)`__  

    要保证操作数的阶数相同,且vec与mat间只存在乘法运算.

    它们的计算方式和线性代数中的矩阵乘法相同,不是逐分量运算.


    ```cpp
    vec2 v = vec2(10., 20.);
    mat2 m = mat2(1., 2.,  3., 4.);
    vec2 w = m * v; // = vec2(1. * 10. + 3. * 20., 2. * 10. + 4. * 20.)
    ...
    vec2 v = vec2(10., 20.);
    mat2 m = mat2(1., 2.,  3., 4.);
    vec2 w = v * m; // = vec2(1. * 10. + 2. * 20., 3. * 10. + 4. * 20.)
    ```
    向量与矩阵的乘法规则如下:

    ![](http://wshxbqq-wshxbqq.stor.sinaapp.com/2016-08-08_16-15-36_966___3.png)


    ![](http://wshxbqq-wshxbqq.stor.sinaapp.com/2016-08-08_16-15-36_284___4.png)



* __`mat(矩阵)` 与 `mat(矩阵)`__   

    要保证操作数的阶数相同.

    在mat与mat的运算中, 除了乘法是线性代数中的矩阵乘法外.其余的运算任为逐分量运算.简单说就是只有乘法是特殊的,其余都和vec与vec运算类似.

    ```cpp
    mat2 a = mat2(1., 2.,  3., 4.);
    mat2 b = mat2(10., 20.,  30., 40.);
    mat2 c = a * b; //mat2(1.*10.+3.*20.,2.*10.+4.*20.,1.* 30.+3.*40.,2.* 30.+4.*40.);
    mat2 d = a+b;//mat2(1.+10.,2.+20.,3.+30.,4.+40);
    ```
    矩阵乘法规则如下:

    ![](http://wshxbqq-wshxbqq.stor.sinaapp.com/2016-08-08_16-15-36_985___5.png)

