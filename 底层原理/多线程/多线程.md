# 多线程  

## 面试  
1. 你理解的多线程？ 
2. iOS的多洗那成方案？ 更倾向于哪种？ 
3. 在项目中用过GCD？ 
4. GCD 队列类型  
5. OperationQueue 和 GCD 的区别，各自优势  
6. 线程安全处理手段？ 
7. OC 的锁有哪些？  
    * 自旋和互斥对比？ 
    * 使用以上锁需要注意哪些？ 
    * 使用C/OC，实现自旋或互斥？ 


## iOS多线程方案  
* pthread  
    * 通用多线程  
    * 适用于多平台  
    * 跨平台 
    * 使用难度大  
    * C 语言实现 
* NSThread
    * 面向对象  
    * 简单易用，可直接操作线程对象  

* GCD 
    * 替代 NSThread 等线程基础  
    * 充分利用多核  

* NSOpertation
    * 基于GCD  
    * 比GCD 多了简单使用功能  
    * 面向对象  


## 同步、异步、并行、串行  
* 同步和异步主要影响： 能否开启新的线程  
    同步： 在当前线程执行 
    异步： 在新的线程执行  


## 问题总结 
### 问题 1  
```
dispatch_queue_t q = dispatch_get_main_queue(); 

NSLog();
dispatch_sync(q, ^{
    NSLOg();
})

NSLog();

```

原因： 以上代码会造成死锁； 由于其在主线程队列，并且是同步的，所以必须要任意一执行完，才能执行添加到队里的任务2， 但由于是同步的，所以这里又需要任务2执行完毕，擦能接着执行任务，导致死锁问题  


### 问题2 
```
dispatch_async(global_queue, ^{

    [self performSelector:@selector(test) withObject:nil afterDelay:.0];
})

```
以上代码中， test方法不会运行， 因为此方法的调用，依赖于runloop，子线程没有runloop，所以无法运行   
`perforSlector: afterDelay`本质是向runloop中添加定时器 


## OSSpinLock   
__自旋锁__ (会一致处于循环等待状态) 
等待锁的线程会一致处于忙等状态，一致占用着CPU资源  

* 目前已经不安全， 可能会出现优先级反转问题   
* 如果等待锁的线程优先级较高， 它会一致占用CPU资源， 优先级低的线程就无法释放锁   


## os_unfair_lock  
用来取代`OSSpinLock`,从底层调用看， 等待 `os_unfair_lock`锁的线程会处于休眠状态，并非忙等    

__低级锁(互斥锁)__  
  



## pthread_Mutex_t(互斥锁)---线程可能进入休眠状态  
```




```



